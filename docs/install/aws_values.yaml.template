# We use global values scope to multiplex the docker-registry details to both mlrun and nuclio
global:
  externalHostAddress: "${CLUSTER_FQDN}"
  domainNameCertificate: ~
  registry:
    url: "${ECR_REPO_NAME}"
  infrastructure:
    kind: cloud
    provider: aws
    inboundCidrs: "${INBOUND_CIDRS}"
    loadBalancerName: "${CLUSTER_NAME}"

nuclio:
  platform:
    kube:
      defaultFunctionServiceAccount: mlrun-main-sa
  registry:
      pushPullUrl: "${ECR_REPO_NAME}"
  dashboard:
    ingress:
      enabled: false
    containerBuilderKind: kaniko
    imageNamePrefixTemplate: "{{ .ProjectName }}-{{ .FunctionName }}-"
    kaniko:
      defaultServiceAccount: mlrun-main-sa

mlrun:
  api:
    envFrom:
      - configMapRef:
          name: mlrun-override-env
          optional: true
    extraEnv:
      - name: S3_NON_ANONYMOUS
        # TODO: Fix mlrun chart to quote values, api-chief-deployment.yaml:115
        value: '"true"'
      - name: MLRUN_DEFAULT_TENSORBOARD_LOGS_PATH
        value: /home/jovyan/data/tensorboard/{{ `{{project}} `}}
      - name: MLRUN_CE__MODE
        value: full
      - name: MLRUN_SPARK_OPERATOR_VERSION
        value: spark-3
      - name: MLRUN_STORAGE__AUTO_MOUNT_TYPE
        value: s3
      - name: MLRUN_STORAGE__AUTO_MOUNT_PARAMS
        value: "non_anonymous=True"
      - name: MLRUN_FUNCTION__SPEC__SERVICE_ACCOUNT__DEFAULT
        value: mlrun-main-sa
      - name: MLRUN_HTTPDB__PROJECTS__FOLLOWERS
        value: nuclio
      - name: MLRUN_HTTPDB__REAL_PATH
        value: s3://
      - name: MLRUN_ARTIFACT_PATH
        value: s3://${BUCKET_NAME}/projects/{{ `{{run.project}} `}}/artifacts/
      - name: MLRUN_SPARK_APP_IMAGE
        value: gcr.io/iguazio/spark-app
      - name: MLRUN_SPARK_APP_IMAGE_TAG
        value: v3.2.1-mlk
      - name: MLRUN_KFP_URL
        value: http://ml-pipeline.mlrun.svc.cluster.local:8888
      - name: MLRUN_REDIS_URL
        value: bo-redis.com
  nuclio:
    uiURL: "https://nuclio.${CLUSTER_FQDN}"
  storage: filesystem
  serviceAccounts:
    api:
      create: false
      name: mlrun-main-sa
      annotations: {}
  v3io:
    enabled: false
    volumes:
      storageOverride:
        persistentVolumeClaim:
          claimName: mlrun-api-pvc
    persistence:
      enabled: true
      storageClass: gp2
      accessMode: "ReadWriteOnce"
      size: "16Gi"
  ui:
    service:
      type: "ClusterIP"
    ingress:
      enabled: false
  db:
    image:
      repository: mysql
      tag: "8.0"
    persistence:
      enabled: true
      storageClass: gp2
      accessMode: "ReadWriteOnce"
      size: "16Gi"

jupyterNotebook:
  enabled: true
  awsInstall: true
  mlrunUIURL:  https://mlrun.${CLUSTER_FQDN}
  envFrom: ~
  extraEnv:
    - name: S3_NON_ANONYMOUS
      value: '"true"'
    - name: MLRUN_HTTPDB__REAL_PATH
      value: s3://
    - name: MLRUN_STORAGE__AUTO_MOUNT_TYPE
      value: s3
    - name: MLRUN_STORAGE__AUTO_MOUNT_PARAMS
      value: "non_anonymous=True"
    - name: MLRUN_FUNCTION__SPEC__SERVICE_ACCOUNT__DEFAULT
      value: mlrun-main-sa
    - name: MLRUN_ARTIFACT_PATH
      value: s3://${BUCKET_NAME}/projects/{{ `{{run.project}} `}}/artifacts/
    - name: MLRUN_CE
      value: '"true"'
  service:
    type: "ClusterIP"
    port: 80
    targetPort: 80
  serviceAccount:
    create: false
    name: mlrun-main-sa
  ingress:
    enabled: false
  image:
    repository: quay.io/mlrun/jupyter
  busybox:
    image: public.ecr.aws/docker/library/busybox
    tag: 1.35

  # use this to override mlrunUIURL, by default it will be auto-resolved to externalHostAddress and
  # mlrun UI's node port
  mlrunURL: mlrun.${CLUSTER_FQDN}
  persistence:
    enabled: true
    existingClaim:
    storageClass: efs-sc
    accessMode: "ReadWriteMany"
    size: "16Gi"

minio:
  enabled: true
  rootUser: minio
  rootPassword: minio123
  mode: standalone
  replicas: 1
  resources:
    requests:
      memory: 0.5Gi
  service:
    type: "ClusterIP"
    port: 9000
    nodePort: 30080
  consoleService:
    type: "ClusterIP"
    port: 9001
    nodePort: 30090
  persistence:
    enabled: true
    size: 4Gi
    storageClass: efs-sc
  fullnameOverride: minio
  buckets:
    - name: mlrun
      policy: none
      purge: false

pipelines:
  mysql:
    repo: public.ecr.aws/docker/library/mysql
    tag: 5.7
  persistence:
    enabled: true
    storageClass: gp2
    accessMode: "ReadWriteOnce"
    size: "16Gi"
  minio:
    enabled: true
    accessKey: "minio"
    secretKey: "minio123"
    endpointPort: "9000"
    bucket: "mlrun"

kube-prometheus-stack:
  grafana:
    persistence:
      type: pvc
      enabled: true
      size: "16Gi"
    service:
      type: ClusterIP
  prometheus:
    enabled: true
    service:
      type: ClusterIP
    prometheusSpec:
      storageSpec:
        volumeClaimTemplate:
          spec:
            storageClassName: gp2
            accessModes: ["ReadWriteOnce"]
            resources:
              requests:
                storage: "16Gi"
